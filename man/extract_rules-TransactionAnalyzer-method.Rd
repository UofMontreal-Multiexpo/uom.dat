% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transaction_analyzer.R
\name{extract_rules,TransactionAnalyzer-method}
\alias{extract_rules,TransactionAnalyzer-method}
\alias{extract_rules}
\title{Rules extraction}
\usage{
\S4method{extract_rules}{TransactionAnalyzer}(
  object,
  itemsets = NULL,
  pruning = FALSE,
  arules = FALSE,
  as_sets = FALSE,
  ...
)
}
\arguments{
\item{object}{S4 object of class \code{TransactionAnalyzer}.}

\item{itemsets}{If not \code{NULL}, character or list of itemsets for which to extract the
association rules.
\itemize{
  \item{If \code{NULL}, look for all rules within the transactions saved in \code{object}
        or for rules with specific items.}
  \item{If \code{"patterns"}, look for rules whose union of the antecedent and the consequent form
        an entire pattern among those contained in \code{object} (more precisely, in
        \code{object["patterns"]$pattern}).}
  \item{Otherwise, a list of itemsets defined the same way as \code{object["patterns"]$pattern}.
        Look for rules whose union of the antecedent and the consequent form an entire itemset.}
}}

\item{pruning}{If \code{TRUE}, remove redundant rules (see 'Details' to know how redundant rules
are defined).}

\item{arules}{If \code{TRUE}, rules are returned as an object of class
\code{\link[arules:rules-class]{rules}} from the package \code{arules}.}

\item{as_sets}{If \code{FALSE}, antecedents and consequents of the returned rules will be character
vectors. If \code{TRUE}, they will be factors written in mathematical notation (i.e. set notation).
Ignored if \code{arules} is \code{TRUE}.}

\item{...}{Additional arguments to configure the extraction. See 'Details'.}
}
\value{
Data frame or object of class \code{rules} (according to the argument \code{arules})
 containing the extracted rules and their characteristics.
 
 If \code{itemsets} is not \code{NULL}, the column \code{"itemset"} refers to the index of the
 one from which the rule was generated in the list of patterns (if \code{from = "patterns"})
 or in the given list (otherwise).
}
\description{
Extract association rules from the transactions (i.e. presence implication between two disjoint
 itemsets). Can be used to find all rules, rules relating to patterns (or other specific itemsets)
 or relating to specific items.
}
\details{
Only creates rules with one item in the consequent. The reason is detailed on
 \href{https://borgelt.net/doc/apriori/apriori.html#conseq}{this web page} by the author of the
 algorithms used. Here are some extracts: \cr
 "\emph{There are usually already (many) more association rules than item sets if only a single
 item is allowed in the consequents.}" \cr
 "\emph{Multiple items in the consequents of association rules therefore come at a considerable
 cost.}" \cr
 "\emph{There is no true benefit.}"

\loadmathjax
The characteristics of an association rule of the form \mjeqn{X \rightarrow Y}{X -> Y} are:
 \itemize{
   \item{The \strong{support}: support of the itemset \mjeqn{X \cup Y}{X union Y}, i.e. the
         proportion of transactions containing \mjeqn{X \cup Y}{X union Y} among all transactions.}
   \item{The \strong{confidence}: quotient of the support of \mjeqn{X \cup Y}{X union Y} and the
         support of \eqn{X}, i.e. the proportion of transactions in which the rule is correct
         relative to the number of transactions containing the antecedent \eqn{X}.}
   \item{The \strong{lift}: quotient of the confidence of \mjeqn{X \rightarrow Y}{X -> Y} and the
         support of \eqn{Y}.}
 }
 
Support and confidence indices measure the strength of a rule.
 A rule can be said to be \strong{valid} if its confidence and its support are greater than two
 chosen thresholds. A rule is said to be \strong{exact} if its confidence is \eqn{1}, otherwise the
 rule is \strong{partial}.
The lift measures the importance of a rule. A lift greater than \eqn{1} reflects a positive
 correlation between the presences of \eqn{X} and \eqn{Y}, and therefore the significant nature of
 the association.
The direction of the rule (i.e. \mjeqn{X \rightarrow Y}{X -> Y} or \mjeqn{Y \rightarrow X}{Y -> X})
 does not impact the support and the lift but does impact the confidence.

A rule is redundant if a more general rule with the same or higher confidence exists. A rule is more
 general if it has the same consequent but one or more items removed from the antecedent. In other
 words, having inferred a dependency \mjeqn{X \rightarrow Y}{X -> Y}, any other dependency of the
 form \mjeqn{X \cup A \rightarrow Y}{X union A -> Y} is considered redundant.

If \code{itemsets = NULL}, additional arguments are \code{parameter}, \code{appearance} and
 \code{control} of function \code{\link[arules:apriori]{apriori}} from the package \code{arules}.
 These arguments allow to specify minimum support (default \code{0.1}), minimum confidence (default
 \code{0.8}), minimum length (default \code{1}), maximum length (default \code{10}), specific items
 in antecedent or consequent, and some operating parameters of the rule extraction algorithm.

If \code{itemsets} is \code{"patterns"} or a list, additional arguments are \code{confidence},
 \code{method}, \code{reduce} and \code{verbose} of function
 \code{\link[arules:ruleInduction]{ruleInduction}} from the package \code{arules}.
 These arguments allow to specify minimum confidence (default \code{0.8}) and some
 operating parameters of the rule extraction algorithm.

Defining minimum support \eqn{s} and confidence \eqn{c} means that the union of items in the
 antecedent and consequent of rules must be present in a minimum of \eqn{s}\% of transactions
 and at least \eqn{c}\% of transactions must satisfy the antecedent.
}
\examples{
## Basic rule extraction
rules_1 <- extract_rules(TA_instance, itemsets = NULL)
rules_2 <- extract_rules(TA_instance, itemsets = "patterns")
rules_3 <- extract_rules(TA_instance, itemsets = list(c("931", "3180"),
                                                      c("25", "192", "328")))

## Rule extraction with conditions on the antecedent and the consequent
params <- list(supp = 0.001, conf = 0.5, maxlen = 2)
rules_4 <- extract_rules(TA_instance,
                         parameter = params,
                         appearance = list(rhs = "328"))
rules_5 <- extract_rules(TA_instance,
                         parameter = params,
                         appearance = list(lhs = "497"))
rules_6 <- extract_rules(TA_instance,
                         parameter = list(supp = 0.001, conf = 0,
                                          minlen = 2, maxlen = 2),
                         appearance = list(lhs = "328", rhs = "3180"))

## Getting rules as an object of class rules from the package arules
rules_7 <- extract_rules(TA_instance, arules = TRUE)
arules::inspect(rules_7)

}
\seealso{
\code{\link{rules_chart}}, \code{\link[arules:rules-class]{arules::rules}}.
}
\author{
Gauthier Magnin
}
